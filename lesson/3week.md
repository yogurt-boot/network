# 그림책 #4, #5

Assignee: yun0 hong
Study: Network

# 4. 결과를 전달하는 HTTP 상태 코드

숫자의 첫 번째 자리는 리스폰스의 클래스

[상태 코드 클래스](https://www.notion.so/b546fa95d05f4822a6731ad9fb731c17)

HTTP 상태 코드는 60종류 이상이 있지만, 실제로 자주 사용되는 것은 14종류 정도

잔인한혜수!

## 2xx 성공(Success)

### `200 OK`

정상 처리. 리스폰스 내용은 리퀘스트 메소드에 따라 다르다.

### `204 No Content`

처리는 성공했지만, 리스폰스에 엔티티 바디를 포함하지 않는다.

클라이언트가 서버에 정보를 보내기만 하고, 서버가 클라이언트에 새로운 정보를 보낼 필요가 없을 때 사용

### `206 Partial Content`

Range에 의해 범위가 지정된 GET 리퀘스트를 받았을 때 사용.

리스폰스에는 Content-Range로 지정된 범위의 엔티티가 포함된다.

## 3xx 리다이렉트(Redirection)

리퀘스트가 정상적으로 처리되기 위해 브라우저 측에서 특별한 처리를 수행해야 함을 나타낸다.

### `301 Moved Permanently`

리퀘스트된 리소스에 새로운 URI가 부여되어, 이후로는 그 리소스를 참조하는 URI를 사용해야 한다는 의미

(책에서는 디렉토리 마지막에 슬래시를 붙여야한다는데 없어도 딱히 301을 반환하지는 않음...)

### `302 Found`

리퀘스트된 리소스에 **일시적**으로 새로운 URI가 할당되어, 그 URI를 참조하라는 의미

### `303 See Other`

리퀘스트된 리소스가 다른 URI에 있기 때문에, **GET** 메소드로 그 URI에 요청하라는 의미

대부분의 브라우저는 301, 302, 303 응답이 오면 엔티티 바디를 삭제하고 새 URI에 GET 요청으로 재송신하게 되어있다.
303만 GET 메소드를 뜻하지만, 실제 구현은 전부 GET으로 재송신한다.

### `304 Not Modified`

클라이언트가 조건부 리퀘스트를 했을 때, 리소스에 대한 엑세스는 허락하지만 조건이 충족되지 않음을 의미

리스폰스 바디에 아무것도 포함하지 않아야 한다.

3xx에 포함되어 있지만, 리다이렉트와는 관계 없다.

### `307 Temporary Redirect`

302와 같지만, 구현 상 302는 GET 메소드로 치환되어 재전송되고 307은 치환하지 않는다.

(But, 브라우저마다 다름)

## 4xx 클라이언트 에러(Client Error)

클라이언트 원인으로 에러가 발생했음을 의미

### `400 Bad Request`

리퀘스트 구문이 잘못됨

리퀘스트 내용을 재검토하여 재송신해야한다.

브라우저는 200 OK와 같이 취급한다. ??!

### `401 Unauthorized`

최초 리퀘스트에는 HTTP 인증(BASIC, DIGEST) 정보가 필요하다는 것을 의미

이미 리퀘스트가 이루어진 경우, 유저 인증에 실패했음을 의미

리퀘스트 된 리소스에 적용되는 challenge를 포함한 WWW-Authenticate 헤더 필드를 포함해야 한다.

브라우저에서 처음 401을 받으면 인증 다이얼로그가 표시된다.

### `403 Forbidden`

리퀘스트된 리소스의 액세스가 거부되었음을 의미

거부의 이유는 엔티티 바디에 기재

### `404 Not Found`

리퀘스트한 리소스가 서버상에 없다는 의미

서버 측이 해당 리퀘스트를 거부하고 싶은 이유를 분명히 하고 싶지 않을 때에도 사용

## 5xx 서버 에러(Server Error)

서버 원인으로 에러가 발생했음을 의미

### `500 Internal Server Error`

서버에서 리퀘스트 처리 도중 에러가 발생했음을 의미

웹 애플리케이션에 에러가 발생했거나 일시적인 경우도 있다.

### `503 Service Unavailable`

일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 현재 리퀘스트를 처리할 수 없음을 의미

이 상태가 해소되기까지 시간이 걸리는 경우에는 Retry-After 헤더 필드를 클라이언트에 전달하는 것이 바람직하다.

# 5. HTTP와 연계하는 웹 서버

## 가상 호스트

물리적으로는 1대이지만 가상으로 여러 대가 있는 것처럼 설정

가상 호스트 시스템을 고려해서 클라이언트가 HTTP 리퀘스트를 보낼 때, 호스트명과 도메인 명을 완전하게 포함한 URI를 지정하거나 Host 헤더필드에서 지정해야 한다.

## 통신을 중계하는 프로그램 :  프록시, 게이트웨이, 터널

### 프록시

서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램

클라이언트의 리퀘스트를 서버에 전송하고, 서버의 리스폰스를 클라이언트에 전송한다.

- 리퀘스트 URI를 변경하지 않고 그 다음의 리소스를 가지고 있는 서버에 전송
- 리소스 본체를 가진 서버가 오리진 서버(Origin Server)
- 오리진 서버의 리스폰스도 프록시 서버를 경유해서 클라이언트로 전송
- 경유할 때마다 **Via** 헤더 필드에 정보를 추가
- 체인처럼 여러 대를 경유하는 것도 가능

**사용하는 이유**

- 캐시를 사용해서 네트워크 대역을 효율적으로 사용
- 액세스 제한
- 액세스 로그

프록시 사용 방법은 캐시여부, 메시지 변경 여부로 구분된다.

**캐싱 프록시(Cashing Proxy)**

리소스 캐시를 보존

같은 리소스에 리퀘스트가 오면 오리진 서버에 가지 않고 캐시를 리스폰스로 내보낸다.

**투명 프록시(Transparent Proxy)**

메시지 변경을 하지 않는 타입의 프록시

검열 등에 사용된다.

**비투과 프록시**

메시지에 변경을 가하는 프록시

### 게이트웨이

다른 서버를 중계하는 서버

클라이언트의 리퀘스트를 해당 서버인 것처럼 수신한다.

클라이언트는 상대가 게이트웨이라는 걸 알지 못하는 경우도 있다.

- 프록시와 매우 유사하지만, 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공한다.
- 암호화 등 통신의 안전성을 높이는 역할 등
- SQL 쿼리로 데이터를 얻는 경우, 결제 시스템 연계 등에 사용

게이트웨이와 프록시의 차이
[https://zorba91.tistory.com/181](https://zorba91.tistory.com/181)

### 터널

서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선한다.

- 다른 서버와의 통신 경로를 확립
- 클라이언트에서 SSL 같은 암호화 통신을 위해 사용
- HTTP 리퀘스트를 해석하지 않고 그대로 다음 서버에 중계한다.
- 터널은 통신하고 있는 양쪽 끝의 접속이 끊어지면 종료된다.

## 캐시

프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본

리소스를 가진 서버의 액세스를 줄여, 통신량과 통신 시간을 절약

캐시 서버는 프록시 서버의 하나로 캐싱 프록시로 분류

### 유효기간

캐시에는 유효기간이 있기 때문에 같은 리소스에 대해 항상 캐시를 반환하지는 않는다.

리소스 갱신을 적용하기 위해 오리진 서버에 리소스의 유효성을 확인하거나 새로운 리소스를 다시 획득하는 경우가 있다.

### 클라이언트 캐시

브라우저에 유효한 캐시가 있을 경우, 서버에 액세스 하지 않고 로컬 디스크로부터 불러온다.

---

# 과제

## HTTP 응답코드에 대해서 설명하세요

HTTP 리퀘스트에 대한 처리 결과를 전달하는 코드이다.

[상태 코드 클래스](https://www.notion.so/dfa58a0454524ae68711f7b635e39574)

## CORS에 대해 설명하세요

- CORS(Cross Origin Resource Sharing)란
  - 웹 서버에게 보안 cross-domain 데이터 전송을 활성화하는 cross-domain 접근 제어권을 부여한다.
- 배경
  - 처음 전송되는 리소스의 도메인과 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청에 의해 요청된다.
  - 보안 상의 이유로, 브라우저들은 스크립트 내에서 초기화되는 cross-origin HTTP 요청을 제한한다.
    - 예를 들면, XMLHttpRequest는 same-origin 정책을 따르기에 XMLHttpRequest을 사용하는 웹 애플리케이션은 자신과 동일한 도메인으로 HTTP 요청을 보내는 것만 가능했다.
    - 웹 애플리케이션을 개선시키기 위해, 개발자들은 브라우저 벤더사들에게 XMLHttpRequest가 cross-domain 요청을 할 수 있도록 요청했고 이에 따라 CORS가 생겼다.
- 과정
  - CORS 요청 시에는 미리 OPTIONS 주소로 서버가 CORS를 허용하는지 물어본다.
  - 이때 Access-Control-Request-Method로 실제로 보내고자 하는 메서드를 알리고,
  - Access-Control-Request-Headers로 실제로 보내고자 하는 헤더들을 알린다.
  - Allow 항목들은 Request에 대응되는 것으로, 서버가 허용하는 메서드와 헤더를 응답하는데 사용된다.
  - Request랑 Allow가 일치하면 CORS 요청이 이루어진다.

[tech-interview/network.md at master · WeareSoft/tech-interview](https://github.com/WeareSoft/tech-interview/blob/master/contents/network.md#cors%EB%9E%80)

[CORS는 왜 이렇게 우리를 힘들게 하는걸까?](
